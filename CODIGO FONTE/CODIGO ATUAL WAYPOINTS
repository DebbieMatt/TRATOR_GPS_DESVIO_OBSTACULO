#include "BluetoothSerial.h"  
#include <ESP32Servo.h>
#include <TinyGPS++.h>

// Verificar se o ESP32 suporta Bluetooth
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

// Motor control pins - Ponte H
#define MOTOR_RIGHT_PIN1 25  // OUT1 da ponte H (motores direita)
#define MOTOR_RIGHT_PIN2 33  // OUT2 da ponte H (motores direita)
#define MOTOR_LEFT_PIN1 32   // OUT3 da ponte H (motores esquerda)
#define MOTOR_LEFT_PIN2 34   // OUT4 da ponte H (motores esquerda)

// PINS PARA ENABLE DA PONTE H (MUITO IMPORTANTE!)
#define MOTOR_RIGHT_ENABLE 26  // Enable para motores direita
#define MOTOR_LEFT_ENABLE 27   // Enable para motores esquerda

// Sensor pins
#define PINO_TRIG 4
#define PINO_ECHO 2
#define PINO_LED 5
#define SERVO_PIN 13

// GPS pins
#define RXD2 16
#define TXD2 17
#define GPS_BAUD 9600

BluetoothSerial SerialBT; 
char comando = 'S';
bool motorsEnabled = true;
bool debugMode = true;

Servo servo1;
TinyGPSPlus gps;
HardwareSerial gpsSerial(2);

// Waypoints pr√©-definidos (latitude, longitude) 
const int NUM_WAYPOINTS = 5; 
const double WAYPOINTS[NUM_WAYPOINTS][2] = {   
  {-56.09878805769986, -15.6816108733274},  // Waypoint 1   
  {-56.09876394510655, -15.68160003000896}, // Waypoint 2   
  {-56.09877912956421, -15.68157591307829}, // Waypoint 3   
  {-56.09880370105573, -15.68158545182519}, // Waypoint 4 
  {-56.09881400464977, -15.68156734210138}  // Waypoint 5
};

// Navega√ß√£o aut√¥noma
int currentWaypoint = 0;
bool autonomousMode = false;
bool waypointReached[NUM_WAYPOINTS] = {false, false, false, false, false};
double currentLat = 0.0;
double currentLng = 0.0;
const double WAYPOINT_THRESHOLD = 0.00002; // ~2 metros de precis√£o

// Timing variables
unsigned long lastCommand = 0;
unsigned long lastDiagnostic = 0;
unsigned long lastNavigation = 0;

void setup() {   
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("=== DIAGN√ìSTICO CARRINHO 4 MOTORES ===");
    Serial.println("Iniciando diagn√≥stico...");
    
    // Initialize motor pins com pulldown
    pinMode(MOTOR_RIGHT_PIN1, OUTPUT);   
    pinMode(MOTOR_RIGHT_PIN2, OUTPUT);   
    pinMode(MOTOR_LEFT_PIN1, OUTPUT);   
    pinMode(MOTOR_LEFT_PIN2, OUTPUT);
    
    // IMPORTANTE: Configurar pinos ENABLE
    pinMode(MOTOR_RIGHT_ENABLE, OUTPUT);
    pinMode(MOTOR_LEFT_ENABLE, OUTPUT);
    
    // ATIVAR os enables da ponte H (CRUCIAL!)
    digitalWrite(MOTOR_RIGHT_ENABLE, HIGH);
    digitalWrite(MOTOR_LEFT_ENABLE, HIGH);
    
    // Garantir que motores iniciem parados
    stopAllMotors();
    
    Serial.println("‚úì Pinos dos motores configurados");
    Serial.println("‚úì ENABLE da ponte H ativados");
    
    // Initialize sensor pins
    pinMode(PINO_TRIG, OUTPUT);
    pinMode(PINO_ECHO, INPUT);
    pinMode(PINO_LED, OUTPUT);
    
    Serial.println("‚úì Sensores configurados");
    
    // Initialize servo
    servo1.attach(SERVO_PIN);
    servo1.write(90);
    
    Serial.println("‚úì Servo configurado");
    
    // Initialize Bluetooth
    if (!SerialBT.begin("Carrinho_Debug")) {
        Serial.println("‚ùå ERRO: Bluetooth n√£o inicializado!");
    } else {
        Serial.println("‚úì Bluetooth: Carrinho_Debug");
    }
    
    // Initialize GPS
    gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
    Serial.println("‚úì GPS configurado");
    
    Serial.println("\n=== TESTE INICIAL DOS MOTORES ===");
    testAllMotors();
    
    Serial.println("\n=== SISTEMA PRONTO ===");
    Serial.println("Comandos Bluetooth:");
    Serial.println("F=Frente | B=R√© | L=Esquerda | R=Direita | S=Parar");
    Serial.println("T=Teste | D=Debug ON/OFF | E=Enable ON/OFF");
    Serial.println("A=Auto Mode | M=Manual | W=Show Waypoints | N=Next Waypoint");
    Serial.println("Envie comandos via Bluetooth ou Serial Monitor");
    Serial.println();
    
    printWaypoints();
}  

void loop() {
    unsigned long currentTime = millis();
    
    // Handle commands from both Bluetooth and Serial
    handleCommands();
    
    // Diagnostic info every 5 seconds
    if (debugMode && (currentTime - lastDiagnostic > 5000)) {
        printDiagnostic();
        lastDiagnostic = currentTime;
    }
    
    // Safety: Stop motors after 5 seconds without command
    if (currentTime - lastCommand > 5000) {
        if (comando != 'S') {
            stopAllMotors();
            comando = 'S';
            Serial.println("‚ö†Ô∏è TIMEOUT: Motores parados por seguran√ßa");
        }
    }
    
    // Update navigation if in autonomous mode
    if (autonomousMode && (currentTime - lastNavigation > 500)) {
        updateNavigation();
        lastNavigation = currentTime;
    }
    
    // Update other systems
    updateSonicSensor();
    updateGPS();
    
    delay(50); // Small delay for stability
}

void handleCommands() {
    char newCommand = 0;
    
    // Check Bluetooth
    if (SerialBT.available()) {
        newCommand = SerialBT.read();
        Serial.print("üì± Bluetooth: ");
    }
    // Check Serial Monitor
    else if (Serial.available()) {
        newCommand = Serial.read();
        Serial.print("üíª Serial: ");
    }
    
    if (newCommand != 0) {
        lastCommand = millis();
        processCommand(newCommand);
    }
}

void processCommand(char cmd) {
    Serial.print("Comando '");
    Serial.print(cmd);
    Serial.println("' recebido");
    
    comando = cmd;
    
    switch (cmd) {
        case 'F': case 'f':
            moveForward();
            break;
        case 'B': case 'b':
            moveBackward();
            break;
        case 'L': case 'l':
            turnLeft();
            break;
        case 'R': case 'r':
            turnRight();
            break;
        case 'G': case 'g':
            curveLeft();
            break;
        case 'I': case 'i':
            curveRight();
            break;
        case 'S': case 's':
            stopAllMotors();
            break;
        case 'T': case 't':
            testAllMotors();
            break;
        case 'D': case 'd':
            debugMode = !debugMode;
            Serial.print("Debug mode: ");
            Serial.println(debugMode ? "ON" : "OFF");
            break;
        case 'E': case 'e':
            motorsEnabled = !motorsEnabled;
            digitalWrite(MOTOR_RIGHT_ENABLE, motorsEnabled ? HIGH : LOW);
            digitalWrite(MOTOR_LEFT_ENABLE, motorsEnabled ? HIGH : LOW);
            Serial.print("Motors enabled: ");
            Serial.println(motorsEnabled ? "ON" : "OFF");
            if (!motorsEnabled) stopAllMotors();
            break;
        case 'V': case 'v':
            checkVoltage();
            break;
        case 'A': case 'a':
            toggleAutonomousMode();
            break;
        case 'M': case 'm':
            autonomousMode = false;
            stopAllMotors();
            Serial.println("üéÆ Modo MANUAL ativado");
            break;
        case 'W': case 'w':
            printWaypoints();
            break;
        case 'N': case 'n':
            nextWaypoint();
            break;
        case 'C': case 'c':
            clearWaypointProgress();
            break;
        default:
            Serial.println("‚ùå Comando inv√°lido!");
            break;
    }
}

// === FUN√á√ïES DE MOVIMENTO ===

void moveForward() {
    if (!motorsEnabled) {
        Serial.println("‚ö†Ô∏è Motores desabilitados!");
        return;
    }
    
    Serial.println("üîÑ FRENTE");
    setRightMotors(HIGH, LOW);
    setLeftMotors(HIGH, LOW);
    
    if (debugMode) {
        Serial.println("  Direita: PIN1=HIGH, PIN2=LOW");
        Serial.println("  Esquerda: PIN1=HIGH, PIN2=LOW");
    }
}

void moveBackward() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ R√â");
    setRightMotors(LOW, HIGH);
    setLeftMotors(LOW, HIGH);
    
    if (debugMode) {
        Serial.println("  Direita: PIN1=LOW, PIN2=HIGH");
        Serial.println("  Esquerda: PIN1=LOW, PIN2=HIGH");
    }
}

void turnLeft() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ ESQUERDA");
    setRightMotors(HIGH, LOW);  // Direita para frente
    setLeftMotors(LOW, HIGH);   // Esquerda para tr√°s
    
    if (debugMode) {
        Serial.println("  Direita: FRENTE");
        Serial.println("  Esquerda: R√â");
    }
}

void turnRight() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ DIREITA");
    setRightMotors(LOW, HIGH);  // Direita para tr√°s
    setLeftMotors(HIGH, LOW);   // Esquerda para frente
    
    if (debugMode) {
        Serial.println("  Direita: R√â");
        Serial.println("  Esquerda: FRENTE");
    }
}

void curveLeft() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ CURVA ESQUERDA");
    setRightMotors(HIGH, LOW);  // S√≥ direita
    setLeftMotors(LOW, LOW);    // Esquerda parada
}

void curveRight() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ CURVA DIREITA");
    setRightMotors(LOW, LOW);   // Direita parada
    setLeftMotors(HIGH, LOW);   // S√≥ esquerda
}

void stopAllMotors() {
    Serial.println("‚èπÔ∏è PARADO");
    setRightMotors(LOW, LOW);
    setLeftMotors(LOW, LOW);
    
    if (debugMode) {
        Serial.println("  Todos os motores: OFF");
    }
}

// === FUN√á√ïES DE CONTROLE BAIXO N√çVEL ===

void setRightMotors(int pin1State, int pin2State) {
    digitalWrite(MOTOR_RIGHT_PIN1, pin1State);
    digitalWrite(MOTOR_RIGHT_PIN2, pin2State);
    
    if (debugMode) {
        Serial.print("  üîß Motores Direita - PIN1(25):");
        Serial.print(pin1State ? "HIGH" : "LOW");
        Serial.print(" PIN2(33):");
        Serial.println(pin2State ? "HIGH" : "LOW");
    }
}

void setLeftMotors(int pin1State, int pin2State) {
    digitalWrite(MOTOR_LEFT_PIN1, pin1State);
    digitalWrite(MOTOR_LEFT_PIN2, pin2State);
    
    if (debugMode) {
        Serial.print("  üîß Motores Esquerda - PIN1(32):");
        Serial.print(pin1State ? "HIGH" : "LOW");
        Serial.print(" PIN2(34):");
        Serial.println(pin2State ? "HIGH" : "LOW");
    }
}

// === FUN√á√ïES DE TESTE ===

void testAllMotors() {
    Serial.println("\nüß™ === TESTE COMPLETO DOS MOTORES ===");
    
    Serial.println("1. Testando motores DIREITA para FRENTE...");
    setRightMotors(HIGH, LOW);
    setLeftMotors(LOW, LOW);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("2. Testando motores DIREITA para TR√ÅS...");
    setRightMotors(LOW, HIGH);
    setLeftMotors(LOW, LOW);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("3. Testando motores ESQUERDA para FRENTE...");
    setRightMotors(LOW, LOW);
    setLeftMotors(HIGH, LOW);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("4. Testando motores ESQUERDA para TR√ÅS...");
    setRightMotors(LOW, LOW);
    setLeftMotors(LOW, HIGH);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("5. Testando TODOS para FRENTE...");
    moveForward();
    delay(2000);
    stopAllMotors();
    
    Serial.println("‚úÖ Teste conclu√≠do!\n");
}

void printDiagnostic() {
    Serial.println("\nüìä === DIAGN√ìSTICO ===");
    Serial.print("‚ö° Motors Enabled: ");
    Serial.println(motorsEnabled ? "‚úÖ YES" : "‚ùå NO");
    Serial.print("üîß Right Enable (26): ");
    Serial.println(digitalRead(MOTOR_RIGHT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("üîß Left Enable (27): ");
    Serial.println(digitalRead(MOTOR_LEFT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("üì± Bluetooth Connected: ");
    Serial.println(SerialBT.hasClient() ? "‚úÖ YES" : "‚ùå NO");
    Serial.print("üì° GPS Satellites: ");
    Serial.println(gps.satellites.value());
    Serial.print("üéØ Last Command: ");
    Serial.println(comando);
    Serial.print("ü§ñ Autonomous Mode: ");
    Serial.println(autonomousMode ? "‚úÖ ON" : "‚ùå OFF");
    if (autonomousMode) {
        Serial.print("üìç Current Waypoint: ");
        Serial.print(currentWaypoint + 1);
        Serial.print("/");
        Serial.println(NUM_WAYPOINTS);
    }
    Serial.println("------------------------");
}

void checkVoltage() {
    Serial.println("üîã === VERIFICA√á√ÉO DE ALIMENTA√á√ÉO ===");
    Serial.println("Verifique:");
    Serial.println("1. Bateria/fonte fornecendo 7V para ponte H");
    Serial.println("2. ESP32 alimentado separadamente (USB/VIN)");
    Serial.println("3. GND comum entre ESP32 e ponte H");
    Serial.println("4. Conex√µes dos motores na ponte H");
    Serial.println("5. Enable da ponte H conectado aos pinos 26 e 27");
    
    // Test digital pins
    Serial.println("\nüîå Estado dos pinos:");
    Serial.print("PIN 25 (Motor Right 1): ");
    Serial.println(digitalRead(MOTOR_RIGHT_PIN1) ? "HIGH" : "LOW");
    Serial.print("PIN 33 (Motor Right 2): ");
    Serial.println(digitalRead(MOTOR_RIGHT_PIN2) ? "HIGH" : "LOW");
    Serial.print("PIN 32 (Motor Left 1): ");
    Serial.println(digitalRead(MOTOR_LEFT_PIN1) ? "HIGH" : "LOW");
    Serial.print("PIN 34 (Motor Left 2): ");
    Serial.println(digitalRead(MOTOR_LEFT_PIN2) ? "HIGH" : "LOW");
    Serial.print("PIN 26 (Right Enable): ");
    Serial.println(digitalRead(MOTOR_RIGHT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("PIN 27 (Left Enable): ");
    Serial.println(digitalRead(MOTOR_LEFT_ENABLE) ? "HIGH" : "LOW");
}

// === FUN√á√ïES DE NAVEGA√á√ÉO AUT√îNOMA ===

void toggleAutonomousMode() {
    autonomousMode = !autonomousMode;
    
    if (autonomousMode) {
        if (gps.location.isValid()) {
            Serial.println("ü§ñ MODO AUT√îNOMO ATIVADO");
            currentWaypoint = 0;
            clearWaypointProgress();
            Serial.print("üéØ Indo para waypoint ");
            Serial.println(currentWaypoint + 1);
        } else {
            autonomousMode = false;
            Serial.println("‚ùå GPS inv√°lido! Modo aut√¥nomo desabilitado.");
        }
    } else {
        stopAllMotors();
        Serial.println("üéÆ Modo MANUAL ativado");
    }
}

void updateNavigation() {
    if (!gps.location.isValid() || currentWaypoint >= NUM_WAYPOINTS) {
        return;
    }
    
    double targetLat = WAYPOINTS[currentWaypoint][0];
    double targetLng = WAYPOINTS[currentWaypoint][1];
    
    // Calculate distance and bearing to target
    double distance = calculateDistance(currentLat, currentLng, targetLat, targetLng);
    double bearing = calculateBearing(currentLat, currentLng, targetLat, targetLng);
    
    // Check for obstacle
    if (checkObstacle()) {
        stopAllMotors();
        Serial.println("‚ö†Ô∏è OBST√ÅCULO detectado! Parando...");
        return;
    }
    
    // Navigate towards waypoint
    if (distance > WAYPOINT_THRESHOLD) {
        navigateToTarget(bearing);
        
        if (debugMode) {
            Serial.print("üìê Dist√¢ncia: ");
            Serial.print(distance * 111320, 1); // Convert to meters approximately
            Serial.print("m | Rumo: ");
            Serial.print(bearing, 1);
            Serial.println("¬∞");
        }
    }
}

void navigateToTarget(double bearing) {
    // Simple navigation logic based on bearing
    // Normalize bearing to 0-360
    if (bearing < 0) bearing += 360;
    
    double currentHeading = 0; // Would need compass for real heading
    double headingDiff = bearing - currentHeading;
    
    // Normalize heading difference to -180 to 180
    while (headingDiff > 180) headingDiff -= 360;
    while (headingDiff < -180) headingDiff += 360;
    
    // Simple steering logic
    if (abs(headingDiff) < 15) {
        // Go straight
        moveForward();
    } else if (headingDiff > 0) {
        // Turn right
        turnRight();
        delay(200);
    } else {
        // Turn left  
        turnLeft();
        delay(200);
    }
}

double calculateDistance(double lat1, double lng1, double lat2, double lng2) {
    // Haversine formula for distance calculation
    double dLat = toRadians(lat2 - lat1);
    double dLng = toRadians(lng2 - lng1);
    
    double a = sin(dLat/2) * sin(dLat/2) + 
               cos(toRadians(lat1)) * cos(toRadians(lat2)) * 
               sin(dLng/2) * sin(dLng/2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1-a));
    return c; // Returns distance in radians (multiply by Earth radius for meters)
}

double calculateBearing(double lat1, double lng1, double lat2, double lng2) {
    double dLng = toRadians(lng2 - lng1);
    double lat1Rad = toRadians(lat1);
    double lat2Rad = toRadians(lat2);
    
    double y = sin(dLng) * cos(lat2Rad);
    double x = cos(lat1Rad) * sin(lat2Rad) - sin(lat1Rad) * cos(lat2Rad) * cos(dLng);
    
    double bearing = toDegrees(atan2(y, x));
    return fmod((bearing + 360.0), 360.0); // Normalize to 0-360
}

double toRadians(double deg) {
    return deg * PI / 180.0;
}

double toDegrees(double rad) {
    return rad * 180.0 / PI;
}

void checkWaypointReached() {
    if (currentWaypoint >= NUM_WAYPOINTS) return;
    
    double distance = calculateDistance(
        currentLat, currentLng, 
        WAYPOINTS[currentWaypoint][0], 
        WAYPOINTS[currentWaypoint][1]
    );
    
    if (distance <= WAYPOINT_THRESHOLD) {
        waypointReached[currentWaypoint] = true;
        Serial.print("‚úÖ WAYPOINT ");
        Serial.print(currentWaypoint + 1);
        Serial.println(" ALCAN√áADO!");
        
        currentWaypoint++;
        
        if (currentWaypoint >= NUM_WAYPOINTS) {
            Serial.println("üéâ TODOS OS WAYPOINTS ALCAN√áADOS!");
            stopAllMotors();
            autonomousMode = false;
            printMissionSummary();
        } else {
            Serial.print("üéØ Pr√≥ximo waypoint: ");
            Serial.println(currentWaypoint + 1);
        }
    }
}

bool checkObstacle() {
    // Read ultrasonic sensor
    digitalWrite(PINO_TRIG, LOW);
    delayMicroseconds(2);
    digitalWrite(PINO_TRIG, HIGH);
    delayMicroseconds(10);
    digitalWrite(PINO_TRIG, LOW);
    
    long duracao = pulseIn(PINO_ECHO, HIGH, 30000);
    if (duracao > 0) {
        float distancia = (duracao * 0.0343) / 2.0;
        return distancia <= 20.0; // Stop if obstacle within 20cm
    }
    return false;
}

void printWaypoints() {
    Serial.println("\nüìç === WAYPOINTS DEFINIDOS ===");
    for (int i = 0; i < NUM_WAYPOINTS; i++) {
        Serial.print("Waypoint ");
        Serial.print(i + 1);
        Serial.print(": ");
        Serial.print(WAYPOINTS[i][0], 8);
        Serial.print(", ");
        Serial.print(WAYPOINTS[i][1], 8);
        Serial.print(" [");
        Serial.print(waypointReached[i] ? "‚úÖ ALCAN√áADO" : "‚è≥ PENDENTE");
        Serial.println("]");
    }
    
    if (gps.location.isValid()) {
        Serial.println("\nüì° Posi√ß√£o atual:");
        Serial.print("LAT: ");
        Serial.print(currentLat, 8);
        Serial.print(" | LNG: ");
        Serial.println(currentLng, 8);
        
        if (autonomousMode && currentWaypoint < NUM_WAYPOINTS) {
            double distance = calculateDistance(
                currentLat, currentLng,
                WAYPOINTS[currentWaypoint][0], 
                WAYPOINTS[currentWaypoint][1]
            );
            Serial.print("üìè Dist√¢ncia para pr√≥ximo waypoint: ");
            Serial.print(distance * 111320, 1);
            Serial.println(" metros");
        }
    } else {
        Serial.println("\n‚ùå GPS sem sinal v√°lido");
    }
    Serial.println();
}

void nextWaypoint() {
    if (currentWaypoint < NUM_WAYPOINTS - 1) {
        currentWaypoint++;
        Serial.print("‚è≠Ô∏è Pulando para waypoint ");
        Serial.println(currentWaypoint + 1);
    } else {
        Serial.println("‚ùå J√° no √∫ltimo waypoint!");
    }
}

void clearWaypointProgress() {
    for (int i = 0; i < NUM_WAYPOINTS; i++) {
        waypointReached[i] = false;
    }
    currentWaypoint = 0;
    Serial.println("üîÑ Progresso dos waypoints resetado");
}

void printMissionSummary() {
    Serial.println("\nüèÅ === MISS√ÉO COMPLETA ===");
    Serial.print("‚úÖ Waypoints alcan√ßados: ");
    
    int reached = 0;
    for (int i = 0; i < NUM_WAYPOINTS; i++) {
        if (waypointReached[i]) reached++;
    }
    
    Serial.print(reached);
    Serial.print("/");
    Serial.println(NUM_WAYPOINTS);
    
    if (reached == NUM_WAYPOINTS) {
        Serial.println("üéâ MISS√ÉO 100% CONCLU√çDA!");
    } else {
        Serial.println("‚ö†Ô∏è Miss√£o incompleta");
    }
    Serial.println();
}

void updateSonicSensor() {
    static unsigned long lastSensorRead = 0;
    if (millis() - lastSensorRead < 100) return;
    
    digitalWrite(PINO_TRIG, LOW);
    delayMicroseconds(2);
    digitalWrite(PINO_TRIG, HIGH);
    delayMicroseconds(10);
    digitalWrite(PINO_TRIG, LOW);
    
    long duracao = pulseIn(PINO_ECHO, HIGH, 30000);
    if (duracao > 0) {
        float distancia = (duracao * 0.0343) / 2.0;
        digitalWrite(PINO_LED, (distancia <= 10.0) ? HIGH : LOW);
    }
    
    lastSensorRead = millis();
}

void updateGPS() {
    while (gpsSerial.available() > 0) {
        if (gps.encode(gpsSerial.read())) {
            if (gps.location.isUpdated() && gps.location.isValid()) {
                currentLat = gps.location.lat();
                currentLng = gps.location.lng();
                
                // Check waypoint proximity
                if (autonomousMode) {
                    checkWaypointReached();
                }
                
                // Print GPS info less frequently
                static uint8_t gpsCounter = 0;
                if (debugMode && (++gpsCounter >= 20)) {
                    Serial.print("üì° GPS: ");
                    Serial.print(currentLat, 8);
                    Serial.print(", ");
                    Serial.print(currentLng, 8);
                    Serial.print(" | Sat: ");
                    Serial.println(gps.satellites.value());
                    gpsCounter = 0;
                }
            }
        }
    }
}
