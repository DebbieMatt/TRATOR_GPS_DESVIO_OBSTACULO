#include "BluetoothSerial.h"  
#include <ESP32Servo.h>
#include <TinyGPS++.h>

// Verificar se o ESP32 suporta Bluetooth
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

// Motor control pins - Ponte H
#define MOTOR_RIGHT_PIN1 25  // OUT1 da ponte H (motores direita)
#define MOTOR_RIGHT_PIN2 33  // OUT2 da ponte H (motores direita)
#define MOTOR_LEFT_PIN1 32   // OUT3 da ponte H (motores esquerda)
#define MOTOR_LEFT_PIN2 34   // OUT4 da ponte H (motores esquerda)

// PINS PARA ENABLE DA PONTE H (MUITO IMPORTANTE!)
#define MOTOR_RIGHT_ENABLE 26  // Enable para motores direita
#define MOTOR_LEFT_ENABLE 27   // Enable para motores esquerda

// Sensor pins
#define PINO_TRIG 4
#define PINO_ECHO 2
#define PINO_LED 5
#define SERVO_PIN 13

// GPS pins
#define RXD2 16
#define TXD2 17
#define GPS_BAUD 9600

BluetoothSerial SerialBT; 
char comando = 'S';
bool motorsEnabled = true;
bool debugMode = true;

Servo servoSonda;
TinyGPSPlus gps;
HardwareSerial gpsSerial(2);

// === CONFIGURA√á√ïES DA SONDA SERVO ===
struct SondaSensor {
    int posicaoAtual = 90;      // Posi√ß√£o atual do servo (centro)
    int posicaoMin = 30;        // √Çngulo m√≠nimo (direita)
    int posicaoMax = 150;       // √Çngulo m√°ximo (esquerda)
    int incremento = 15;        // Incremento de varredura
    bool varrendo = false;      // Estado de varredura
    bool direcaoPositiva = true; // Dire√ß√£o da varredura
    float distancias[9];        // Array para armazenar dist√¢ncias (30¬∞, 45¬∞, 60¬∞, 75¬∞, 90¬∞, 105¬∞, 120¬∞, 135¬∞, 150¬∞)
    int indiceAtual = 4;        // √çndice atual no array (come√ßa no centro - 90¬∞)
    unsigned long ultimaVarredura = 0;
    const unsigned long intervalVarredura = 300; // Intervalo entre medi√ß√µes (ms)
    float obstaculoProximo = 25.0;  // Dist√¢ncia considerada como obst√°culo pr√≥ximo (cm)
    bool obstaculoDetectado = false;
    int direcaoLivre = 90;      // Dire√ß√£o com maior espa√ßo livre
};

SondaSensor sonda;

// Waypoints pr√©-definidos (latitude, longitude) 
const int NUM_WAYPOINTS = 5; 
const double WAYPOINTS[NUM_WAYPOINTS][2] = {   
  {-56.09878805769986, -15.6816108733274},  // Waypoint 1   
  {-56.09876394510655, -15.68160003000896}, // Waypoint 2   
  {-56.09877912956421, -15.68157591307829}, // Waypoint 3   
  {-56.09880370105573, -15.68158545182519}, // Waypoint 4 
  {-56.09881400464977, -15.68156734210138}  // Waypoint 5
};

// Navega√ß√£o aut√¥noma
int currentWaypoint = 0;
bool autonomousMode = true; // INICIA AUTOMATICAMENTE EM MODO AUT√îNOMO
bool waypointReached[NUM_WAYPOINTS] = {false, false, false, false, false};
double currentLat = 0.0;
double currentLng = 0.0;
const double WAYPOINT_THRESHOLD = 0.00002; // ~2 metros de precis√£o
bool manualOverride = false; // Flag para controle manual tempor√°rio
unsigned long lastManualCommand = 0;
const unsigned long MANUAL_TIMEOUT = 3000; // 3 segundos para retornar ao aut√¥nomo

// Timing variables
unsigned long lastCommand = 0;
unsigned long lastDiagnostic = 0;
unsigned long lastNavigation = 0;

void setup() {   
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("=== DIAGN√ìSTICO CARRINHO 4 MOTORES COM SONDA ===");
    Serial.println("Iniciando diagn√≥stico...");
    
    // Initialize motor pins com pulldown
    pinMode(MOTOR_RIGHT_PIN1, OUTPUT);   
    pinMode(MOTOR_RIGHT_PIN2, OUTPUT);   
    pinMode(MOTOR_LEFT_PIN1, OUTPUT);   
    pinMode(MOTOR_LEFT_PIN2, OUTPUT);
    
    // IMPORTANTE: Configurar pinos ENABLE
    pinMode(MOTOR_RIGHT_ENABLE, OUTPUT);
    pinMode(MOTOR_LEFT_ENABLE, OUTPUT);
    
    // ATIVAR os enables da ponte H (CRUCIAL!)
    digitalWrite(MOTOR_RIGHT_ENABLE, HIGH);
    digitalWrite(MOTOR_LEFT_ENABLE, HIGH);
    
    // Garantir que motores iniciem parados
    stopAllMotors();
    
    Serial.println("‚úì Pinos dos motores configurados");
    Serial.println("‚úì ENABLE da ponte H ativados");
    
    // Initialize sensor pins
    pinMode(PINO_TRIG, OUTPUT);
    pinMode(PINO_ECHO, INPUT);
    pinMode(PINO_LED, OUTPUT);
    
    Serial.println("‚úì Sensores configurados");
    
    // Initialize servo sonda
    servoSonda.attach(SERVO_PIN);
    servoSonda.write(sonda.posicaoAtual);
    delay(1000); // Aguardar servo se posicionar
    
    Serial.println("‚úì Servo sonda configurado e posicionado no centro");
    
    // Initialize Bluetooth
    if (!SerialBT.begin("Carrinho_Sonda")) {
        Serial.println("‚úó ERRO: Bluetooth n√£o inicializado!");
    } else {
        Serial.println("‚úì Bluetooth: Carrinho_Sonda");
    }
    
    // Initialize GPS
    gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
    Serial.println("‚úì GPS configurado");
    
    // Inicializar array de dist√¢ncias
    for (int i = 0; i < 9; i++) {
        sonda.distancias[i] = 999.0; // Valor inicial alto
    }
    
    Serial.println("\n=== TESTE INICIAL DOS MOTORES ===");
    testAllMotors();
    
    Serial.println("\n=== TESTE DA SONDA ===");
    testSondaServo();
    
    Serial.println("\n=== SISTEMA PRONTO ===");
    Serial.println("Comandos Bluetooth:");
    Serial.println("F=Frente | B=R√© | L=Esquerda | R=Direita | S=Parar");
    Serial.println("T=Teste | D=Debug ON/OFF | E=Enable ON/OFF");
    Serial.println("A=Auto Mode | M=Manual | W=Show Waypoints | N=Next Waypoint");
    Serial.println("P=Scan ON/OFF | Q=Quick Scan | X=Centro Servo | Z=Reset Sonda");
    Serial.println("Envie comandos via Bluetooth ou Serial Monitor");
    Serial.println();
    
    printWaypoints();
    
    // Iniciar varredura autom√°tica
    sonda.varrendo = true;
    Serial.println("üîç Sonda em modo varredura autom√°tica");
}  

void loop() {
    unsigned long currentTime = millis();
    
    // Handle commands from both Bluetooth and Serial
    handleCommands();
    
    // Update servo sonda
    updateServoSonda();
    
    // Diagnostic info every 5 seconds
    if (debugMode && (currentTime - lastDiagnostic > 5000)) {
        printDiagnostic();
        lastDiagnostic = currentTime;
    }
    
    // Safety: Stop motors after 5 seconds without command
    if (currentTime - lastCommand > 5000) {
        if (comando != 'S') {
            stopAllMotors();
            comando = 'S';
            Serial.println("‚ö†Ô∏è TIMEOUT: Motores parados por seguran√ßa");
        }
    }
    
    // Check for manual override timeout
    if (manualOverride && (currentTime - lastManualCommand > MANUAL_TIMEOUT)) {
        manualOverride = false;
        Serial.println("‚è∞ Retornando ao modo AUT√îNOMO");
    }
    
    // Update navigation if in autonomous mode
    if (autonomousMode && !manualOverride && (currentTime - lastNavigation > 500)) {
        updateNavigation();
        lastNavigation = currentTime;
    }
    
    // Update other systems
    updateGPS();
    
    delay(50); // Small delay for stability
}

void handleCommands() {
    char newCommand = 0;
    
    // Check Bluetooth
    if (SerialBT.available()) {
        newCommand = SerialBT.read();
        Serial.print("üì± Bluetooth: ");
    }
    // Check Serial Monitor
    else if (Serial.available()) {
        newCommand = Serial.read();
        Serial.print("üíª Serial: ");
    }
    
    if (newCommand != 0) {
        lastCommand = millis();
        processCommand(newCommand);
    }
}

void processCommand(char cmd) {
    Serial.print("üì± Comando '");
    Serial.print(cmd);
    Serial.print("' recebido");
    
    // Check if it's a movement command (manual override)
    if (cmd == 'F' || cmd == 'f' || cmd == 'B' || cmd == 'b' || 
        cmd == 'L' || cmd == 'l' || cmd == 'R' || cmd == 'r' || 
        cmd == 'G' || cmd == 'g' || cmd == 'I' || cmd == 'i' || 
        cmd == 'S' || cmd == 's') {
        
        manualOverride = true;
        lastManualCommand = millis();
        Serial.println(" - CONTROLE MANUAL ATIVO");
    } else {
        Serial.println();
    }
    
    comando = cmd;
    
    switch (cmd) {
        case 'F': case 'f':
            moveForward();
            break;
        case 'B': case 'b':
            moveBackward();
            break;
        case 'L': case 'l':
            turnLeft();
            break;
        case 'R': case 'r':
            turnRight();
            break;
        case 'G': case 'g':
            curveLeft();
            break;
        case 'I': case 'i':
            curveRight();
            break;
        case 'S': case 's':
            stopAllMotors();
            break;
        case 'T': case 't':
            testAllMotors();
            break;
        case 'D': case 'd':
            debugMode = !debugMode;
            Serial.print("Debug mode: ");
            Serial.println(debugMode ? "ON" : "OFF");
            break;
        case 'E': case 'e':
            motorsEnabled = !motorsEnabled;
            digitalWrite(MOTOR_RIGHT_ENABLE, motorsEnabled ? HIGH : LOW);
            digitalWrite(MOTOR_LEFT_ENABLE, motorsEnabled ? HIGH : LOW);
            Serial.print("Motors enabled: ");
            Serial.println(motorsEnabled ? "ON" : "OFF");
            if (!motorsEnabled) stopAllMotors();
            break;
        case 'V': case 'v':
            checkVoltage();
            break;
        case 'A': case 'a':
            // Force autonomous mode ON
            autonomousMode = true;
            manualOverride = false;
            sonda.varrendo = true;
            Serial.println("ü§ñ Modo AUT√îNOMO for√ßado - Sonda ativada");
            break;
        case 'M': case 'm':
            // Force manual override
            manualOverride = true;
            lastManualCommand = millis();
            stopAllMotors();
            Serial.println("üéÆ Override MANUAL for√ßado");
            break;
        case 'W': case 'w':
            printWaypoints();
            break;
        case 'N': case 'n':
            nextWaypoint();
            break;
        case 'C': case 'c':
            clearWaypointProgress();
            break;
        // === NOVOS COMANDOS PARA SONDA ===
        case 'P': case 'p':
            toggleSondaVarredura();
            break;
        case 'Q': case 'q':
            executarVarreduraCompleta();
            break;
        case 'X': case 'x':
            centralizarSonda();
            break;
        case 'Z': case 'z':
            resetSonda();
            break;
        default:
            Serial.println("‚úó Comando inv√°lido!");
            break;
    }
}

// === FUN√á√ïES DE MOVIMENTO ===

void moveForward() {
    if (!motorsEnabled) {
        Serial.println("‚ö†Ô∏è Motores desabilitados!");
        return;
    }
    
    // Verificar se h√° obst√°culo √† frente antes de mover
    if (sonda.obstaculoDetectado && !manualOverride) {
        Serial.println("‚ö†Ô∏è OBST√ÅCULO DETECTADO - Movimento bloqueado!");
        stopAllMotors();
        return;
    }
    
    if (manualOverride) {
        Serial.println("üéÆ MANUAL: FRENTE");
    } else {
        Serial.println("ü§ñ AUTO: FRENTE");
    }
    
    setRightMotors(HIGH, LOW);
    setLeftMotors(HIGH, LOW);
    
    if (debugMode) {
        Serial.println("  Direita: PIN1=HIGH, PIN2=LOW");
        Serial.println("  Esquerda: PIN1=HIGH, PIN2=LOW");
    }
}

void moveBackward() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ R√â");
    setRightMotors(LOW, HIGH);
    setLeftMotors(LOW, HIGH);
    
    if (debugMode) {
        Serial.println("  Direita: PIN1=LOW, PIN2=HIGH");
        Serial.println("  Esquerda: PIN1=LOW, PIN2=HIGH");
    }
}

void turnLeft() {
    if (!motorsEnabled) return;
    
    if (manualOverride) {
        Serial.println("üéÆ MANUAL: ESQUERDA");
    } else {
        Serial.println("ü§ñ AUTO: ESQUERDA");
    }
    
    setRightMotors(HIGH, LOW);  // Direita para frente
    setLeftMotors(LOW, HIGH);   // Esquerda para tr√°s
    
    if (debugMode) {
        Serial.println("  Direita: FRENTE");
        Serial.println("  Esquerda: R√â");
    }
}

void turnRight() {
    if (!motorsEnabled) return;
    
    if (manualOverride) {
        Serial.println("üéÆ MANUAL: DIREITA");
    } else {
        Serial.println("ü§ñ AUTO: DIREITA");
    }
    
    setRightMotors(LOW, HIGH);  // Direita para tr√°s
    setLeftMotors(HIGH, LOW);   // Esquerda para frente
    
    if (debugMode) {
        Serial.println("  Direita: R√â");
        Serial.println("  Esquerda: FRENTE");
    }
}

void curveLeft() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ CURVA ESQUERDA");
    setRightMotors(HIGH, LOW);  // S√≥ direita
    setLeftMotors(LOW, LOW);    // Esquerda parada
}

void curveRight() {
    if (!motorsEnabled) return;
    
    Serial.println("üîÑ CURVA DIREITA");
    setRightMotors(LOW, LOW);   // Direita parada
    setLeftMotors(HIGH, LOW);   // S√≥ esquerda
}

void stopAllMotors() {
    if (manualOverride) {
        Serial.println("üéÆ MANUAL: PARADO");
    } else if (autonomousMode) {
        Serial.println("ü§ñ AUTO: PARADO");
    } else {
        Serial.println("‚ÑπÔ∏è PARADO");
    }
    
    setRightMotors(LOW, LOW);
    setLeftMotors(LOW, LOW);
    
    if (debugMode) {
        Serial.println("  Todos os motores: OFF");
    }
}

// === FUN√á√ïES DE CONTROLE BAIXO N√çVEL ===

void setRightMotors(int pin1State, int pin2State) {
    digitalWrite(MOTOR_RIGHT_PIN1, pin1State);
    digitalWrite(MOTOR_RIGHT_PIN2, pin2State);
    
    if (debugMode) {
        Serial.print("  üîß Motores Direita - PIN1(25):");
        Serial.print(pin1State ? "HIGH" : "LOW");
        Serial.print(" PIN2(33):");
        Serial.println(pin2State ? "HIGH" : "LOW");
    }
}

void setLeftMotors(int pin1State, int pin2State) {
    digitalWrite(MOTOR_LEFT_PIN1, pin1State);
    digitalWrite(MOTOR_LEFT_PIN2, pin2State);
    
    if (debugMode) {
        Serial.print("  üîß Motores Esquerda - PIN1(32):");
        Serial.print(pin1State ? "HIGH" : "LOW");
        Serial.print(" PIN2(34):");
        Serial.println(pin2State ? "HIGH" : "LOW");
    }
}

// === FUN√á√ïES DA SONDA SERVO ===

void updateServoSonda() {
    unsigned long currentTime = millis();
    
    if (!sonda.varrendo || (currentTime - sonda.ultimaVarredura < sonda.intervalVarredura)) {
        return;
    }
    
    // Medir dist√¢ncia na posi√ß√£o atual
    float distancia = medirDistanciaAtual();
    
    // Armazenar medi√ß√£o no array
    sonda.distancias[sonda.indiceAtual] = distancia;
    
    if (debugMode) {
        Serial.print("üîç Sonda ");
        Serial.print(sonda.posicaoAtual);
        Serial.print("¬∞: ");
        Serial.print(distancia);
        Serial.println(" cm");
    }
    
    // Verificar se h√° obst√°culo pr√≥ximo
    if (distancia <= sonda.obstaculoProximo) {
        sonda.obstaculoDetectado = true;
        digitalWrite(PINO_LED, HIGH);
    } else {
        digitalWrite(PINO_LED, LOW);
    }
    
    // Mover servo para pr√≥xima posi√ß√£o
    if (sonda.direcaoPositiva) {
        sonda.posicaoAtual += sonda.incremento;
        sonda.indiceAtual++;
        
        if (sonda.posicaoAtual >= sonda.posicaoMax) {
            sonda.direcaoPositiva = false;
        }
    } else {
        sonda.posicaoAtual -= sonda.incremento;
        sonda.indiceAtual--;
        
        if (sonda.posicaoAtual <= sonda.posicaoMin) {
            sonda.direcaoPositiva = true;
            // Completou um ciclo completo - analisar obst√°culos
            analisarVarredura();
        }
    }
    
    // Limitar posi√ß√£o e √≠ndice
    sonda.posicaoAtual = constrain(sonda.posicaoAtual, sonda.posicaoMin, sonda.posicaoMax);
    sonda.indiceAtual = constrain(sonda.indiceAtual, 0, 8);
    
    // Mover servo
    servoSonda.write(sonda.posicaoAtual);
    sonda.ultimaVarredura = currentTime;
}

float medirDistanciaAtual() {
    digitalWrite(PINO_TRIG, LOW);
    delayMicroseconds(2);
    digitalWrite(PINO_TRIG, HIGH);
    delayMicroseconds(10);
    digitalWrite(PINO_TRIG, LOW);
    
    long duracao = pulseIn(PINO_ECHO, HIGH, 30000);
    if (duracao > 0) {
        return (duracao * 0.0343) / 2.0;
    }
    return 999.0; // Valor alto se n√£o detectou nada
}

void analisarVarredura() {
    float maiorDistancia = 0.0;
    int melhorDirecao = 90; // Centro como padr√£o
    bool obstaculoGeral = false;
    
    // Encontrar dire√ß√£o com maior espa√ßo livre
    for (int i = 0; i < 9; i++) {
        int angulo = sonda.posicaoMin + (i * sonda.incremento);
        
        if (sonda.distancias[i] > maiorDistancia) {
            maiorDistancia = sonda.distancias[i];
            melhorDirecao = angulo;
        }
        
        if (sonda.distancias[i] <= sonda.obstaculoProximo) {
            obstaculoGeral = true;
        }
    }
    
    sonda.direcaoLivre = melhorDirecao;
    sonda.obstaculoDetectado = (sonda.distancias[4] <= sonda.obstaculoProximo); // Centro
    
    if (debugMode) {
        Serial.println("\nüîç === AN√ÅLISE DE VARREDURA ===");
        printVarreduraCompleta();
        Serial.print("üéØ Melhor dire√ß√£o: ");
        Serial.print(melhorDirecao);
        Serial.print("¬∞ (");
        Serial.print(maiorDistancia);
        Serial.println(" cm)");
        
        if (sonda.obstaculoDetectado) {
            Serial.println("‚ö†Ô∏è OBST√ÅCULO √Ä FRENTE!");
        } else {
            Serial.println("‚úÖ Caminho livre √† frente");
        }
        Serial.println("============================\n");
    }
}

void toggleSondaVarredura() {
    sonda.varrendo = !sonda.varrendo;
    Serial.print("üîç Varredura da sonda: ");
    Serial.println(sonda.varrendo ? "ATIVADA" : "DESATIVADA");
    
    if (!sonda.varrendo) {
        centralizarSonda();
    }
}

void executarVarreduraCompleta() {
    Serial.println("üîç Executando varredura completa...");
    
    // Garantir que est√° no centro
    sonda.posicaoAtual = 90;
    sonda.indiceAtual = 4;
    servoSonda.write(sonda.posicaoAtual);
    delay(500);
    
    // Varredura completa de 30¬∞ a 150¬∞
    for (int i = 0; i < 9; i++) {
        int angulo = sonda.posicaoMin + (i * sonda.incremento);
        sonda.posicaoAtual = angulo;
        sonda.indiceAtual = i;
        
        servoSonda.write(angulo);
        delay(300); // Aguardar servo se posicionar
        
        float distancia = medirDistanciaAtual();
        sonda.distancias[i] = distancia;
        
        Serial.print("üìç ");
        Serial.print(angulo);
        Serial.print("¬∞: ");
        Serial.print(distancia);
        Serial.println(" cm");
    }
    
    analisarVarredura();
    centralizarSonda();
}

void centralizarSonda() {
    Serial.println("üéØ Centralizando sonda...");
    sonda.posicaoAtual = 90;
    sonda.indiceAtual = 4;
    servoSonda.write(90);
    delay(500);
}

void resetSonda() {
    Serial.println("üîÑ Reset da sonda...");
    
    // Resetar todas as vari√°veis
    sonda.posicaoAtual = 90;
    sonda.indiceAtual = 4;
    sonda.varrendo = true;
    sonda.direcaoPositiva = true;
    sonda.obstaculoDetectado = false;
    sonda.direcaoLivre = 90;
    
    // Resetar array de dist√¢ncias
    for (int i = 0; i < 9; i++) {
        sonda.distancias[i] = 999.0;
    }
    
    centralizarSonda();
    Serial.println("‚úÖ Sonda resetada e pronta");
}

void printVarreduraCompleta() {
    Serial.println("üìä Dados da varredura:");
    for (int i = 0; i < 9; i++) {
        int angulo = sonda.posicaoMin + (i * sonda.incremento);
        Serial.print("  ");
        Serial.print(angulo);
        Serial.print("¬∞: ");
        
        if (sonda.distancias[i] >= 999.0) {
            Serial.println("---");
        } else {
            Serial.print(sonda.distancias[i]);
            Serial.print(" cm");
            
            if (sonda.distancias[i] <= sonda.obstaculoProximo) {
                Serial.print(" ‚ö†Ô∏è");
            } else {
                Serial.print(" ‚úÖ");
            }
            Serial.println();
        }
    }
}

// === FUN√á√ïES DE TESTE ===

void testAllMotors() {
    Serial.println("\nüß™ === TESTE COMPLETO DOS MOTORES ===");
    
    Serial.println("1. Testando motores DIREITA para FRENTE...");
    setRightMotors(HIGH, LOW);
    setLeftMotors(LOW, LOW);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("2. Testando motores DIREITA para TR√ÅS...");
    setRightMotors(LOW, HIGH);
    setLeftMotors(LOW, LOW);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("3. Testando motores ESQUERDA para FRENTE...");
    setRightMotors(LOW, LOW);
    setLeftMotors(HIGH, LOW);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("4. Testando motores ESQUERDA para TR√ÅS...");
    setRightMotors(LOW, LOW);
    setLeftMotors(LOW, HIGH);
    delay(1500);
    stopAllMotors();
    delay(500);
    
    Serial.println("5. Testando TODOS para FRENTE...");
    moveForward();
    delay(2000);
    stopAllMotors();
    
    Serial.println("‚úÖ Teste conclu√≠do!\n");
}

void testSondaServo() {
    Serial.println("üß™ === TESTE DA SONDA SERVO ===");
    
    Serial.println("1. Movendo para posi√ß√£o m√≠nima (30¬∞)...");
    servoSonda.write(30);
    delay(1000);
    
    Serial.println("2. Movendo para posi√ß√£o m√°xima (150¬∞)...");
    servoSonda.write(150);
    delay(1000);
    
    Serial.println("3. Retornando ao centro (90¬∞)...");
    servoSonda.write(90);
    delay(1000);
    
    Serial.println("4. Teste de varredura r√°pida...");
    for (int pos = 30; pos <= 150; pos += 15) {
        servoSonda.write(pos);
        delay(200);
        float dist = medirDistanciaAtual();
        Serial.print("   ");
        Serial.print(pos);
        Serial.print("¬∞: ");
        Serial.print(dist);
        Serial.println(" cm");
    }
    
    centralizarSonda();
    Serial.println("‚úÖ Teste da sonda conclu√≠do!\n");
}

void printDiagnostic() {
    Serial.println("\nüìä === DIAGN√ìSTICO ===");
    Serial.print("‚ö° Motors Enabled: ");
    Serial.println(motorsEnabled ? "‚úÖ YES" : "‚úó NO");
    Serial.print("üîß Right Enable (26): ");
    Serial.println(digitalRead(MOTOR_RIGHT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("üîß Left Enable (27): ");
    Serial.println(digitalRead(MOTOR_LEFT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("üì± Bluetooth Connected: ");
    Serial.println(SerialBT.hasClient() ? "‚úÖ YES" : "‚úó NO");
    Serial.print("üì° GPS Satellites: ");
    Serial.println(gps.satellites.value());
    Serial.print("üéØ Last Command: ");
    Serial.println(comando);
    Serial.print("ü§ñ Autonomous Mode: ");
    Serial.println(autonomousMode ? "‚úÖ ON" : "‚úó OFF");
    Serial.print("üéÆ Manual Override: ");
    Serial.println(manualOverride ? "‚úÖ ATIVO" : "‚úó INATIVO");
    
    // Diagn√≥stico da sonda
    Serial.println("--- SONDA ---");
    Serial.print("üîç Varredura: ");
    Serial.println(sonda.varrendo ? "‚úÖ ATIVA" : "‚úó INATIVA");
    Serial.print("üìç Posi√ß√£o atual: ");
    Serial.print(sonda.posicaoAtual);
    Serial.println("¬∞");
    Serial.print("‚ö†Ô∏è Obst√°culo detectado: ");
    Serial.println(sonda.obstaculoDetectado ? "SIM" : "N√ÉO");
    Serial.print("üéØ Dire√ß√£o livre: ");
    Serial.print(sonda.direcaoLivre);
    Serial.println("¬∞");
    
    if (autonomousMode && !manualOverride) {
        Serial.print("üîç Current Waypoint: ");
        Serial.print(currentWaypoint + 1);
        Serial.print("/");
        Serial.println(NUM_WAYPOINTS);
        
        if (gps.location.isValid()) {
            Serial.println("üõ∞Ô∏è GPS: V√ÅLIDO");
        } else {
            Serial.println("‚úó GPS: AGUARDANDO SINAL");
        }
    }
    
    if (manualOverride) {
        unsigned long timeLeft = MANUAL_TIMEOUT - (millis() - lastManualCommand);
        if (timeLeft > 0) {
            Serial.print("‚è∞ Retorno ao AUTO em: ");
            Serial.print(timeLeft / 1000);
            Serial.println("s");
        }
    }
    Serial.println("------------------------");
}

void checkVoltage() {
    Serial.println("üîã === VERIFICA√á√ÉO DE ALIMENTA√á√ÉO ===");
    Serial.println("Verifique:");
    Serial.println("1. Bateria/fonte fornecendo 7V para ponte H");
    Serial.println("2. ESP32 alimentado separadamente (USB/VIN)");
    Serial.println("3. GND comum entre ESP32 e ponte H");
    Serial.println("4. Conex√µes dos motores na ponte H");
    Serial.println("5. Enable da ponte H conectado aos pinos 26 e 27");
    Serial.println("6. Servo conectado ao pino 13 com alimenta√ß√£o adequada");
    
    // Test digital pins
    Serial.println("\nüîå Estado dos pinos:");
    Serial.print("PIN 25 (Motor Right 1): ");
    Serial.println(digitalRead(MOTOR_RIGHT_PIN1) ? "HIGH" : "LOW");
    Serial.print("PIN 33 (Motor Right 2): ");
    Serial.println(digitalRead(MOTOR_RIGHT_PIN2) ? "HIGH" : "LOW");
    Serial.print("PIN 32 (Motor Left 1): ");
    Serial.println(digitalRead(MOTOR_LEFT_PIN1) ? "HIGH" : "LOW");
    Serial.print("PIN 34 (Motor Left 2): ");
    Serial.println(digitalRead(MOTOR_LEFT_PIN2) ? "HIGH" : "LOW");
    Serial.print("PIN 26 (Right Enable): ");
    Serial.println(digitalRead(MOTOR_RIGHT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("PIN 27 (Left Enable): ");
    Serial.println(digitalRead(MOTOR_LEFT_ENABLE) ? "HIGH" : "LOW");
    Serial.print("PIN 13 (Servo): Posi√ß√£o ");
    Serial.println(sonda.posicaoAtual);
}

// === FUN√á√ïES DE NAVEGA√á√ÉO AUT√îNOMA ===

void toggleAutonomousMode() {
    autonomousMode = !autonomousMode;
    
    if (autonomousMode) {
        if (gps.location.isValid()) {
            Serial.println("ü§ñ MODO AUT√îNOMO ATIVADO");
            currentWaypoint = 0;
            clearWaypointProgress();
            sonda.varrendo = true; // Ativar sonda em modo aut√¥nomo
            Serial.print("üéØ Indo para waypoint ");
            Serial.println(currentWaypoint + 1);
        } else {
            autonomousMode = false;
            Serial.println("‚úó GPS inv√°lido! Modo aut√¥nomo desabilitado.");
        }
    } else {
        stopAllMotors();
        Serial.println("üéÆ Modo MANUAL ativado");
    }
}

void updateNavigation() {
    // Only run if not in manual override and GPS is valid
    if (manualOverride || !gps.location.isValid() || currentWaypoint >= NUM_WAYPOINTS) {
        return;
    }
    
    double targetLat = WAYPOINTS[currentWaypoint][0];
    double targetLng = WAYPOINTS[currentWaypoint][1];
    
    // Calculate distance and bearing to target
    double distance = calculateDistance(currentLat, currentLng, targetLat, targetLng);
    double bearing = calculateBearing(currentLat, currentLng, targetLat, targetLng);
    
    // Check for obstacle using sonda
    if (sonda.obstaculoDetectado) {
        handleObstacleAvoidance();
        return;
    }
    
    // Navigate towards waypoint
    if (distance > WAYPOINT_THRESHOLD) {
        navigateToTarget(bearing);
        
        if (debugMode) {
            Serial.print("üéØ AUTO NAV - Dist: ");
            Serial.print(distance * 111320, 1); // Convert to meters approximately
            Serial.print("m | Rumo: ");
            Serial.print(bearing, 1);
            Serial.println("¬∞");
        }
    }
}

void handleObstacleAvoidance() {
    static unsigned long lastAvoidance = 0;
    unsigned long currentTime = millis();
    
    if (currentTime - lastAvoidance < 2000) {
        return; // Evitar comandos muito frequentes
    }
    
    stopAllMotors();
    Serial.println("üöß DESVIO DE OBST√ÅCULO ATIVADO");
    
    // Analisar melhor dire√ß√£o baseada na sonda
    int melhorDirecao = sonda.direcaoLivre;
    
    Serial.print("üß≠ Dire√ß√£o livre detectada: ");
    Serial.print(melhorDirecao);
    Serial.println("¬∞");
    
    if (melhorDirecao < 60) {
        // Virar para direita
        Serial.println("üîÑ Desviando para DIREITA");
        turnRight();
        delay(800);
    } else if (melhorDirecao > 120) {
        // Virar para esquerda
        Serial.println("üîÑ Desviando para ESQUERDA");
        turnLeft();
        delay(800);
    } else {
        // Tentar ir em frente se a dire√ß√£o livre √© pr√≥xima ao centro
        Serial.println("üîÑ Tentando continuar em frente");
        moveForward();
        delay(500);
    }
    
    lastAvoidance = currentTime;
}

void navigateToTarget(double bearing) {
    // Enhanced navigation logic using obstacle data
    double currentHeading = 0; // Would need compass for real heading
    double headingDiff = bearing - currentHeading;
    
    // Normalize heading difference to -180 to 180
    while (headingDiff > 180) headingDiff -= 360;
    while (headingDiff < -180) headingDiff += 360;
    
    // Check if path is clear before moving
    if (sonda.obstaculoDetectado) {
        handleObstacleAvoidance();
        return;
    }
    
    // Simple steering logic
    if (abs(headingDiff) < 15) {
        // Go straight
        moveForward();
    } else if (headingDiff > 0) {
        // Turn right
        turnRight();
        delay(200);
    } else {
        // Turn left  
        turnLeft();
        delay(200);
    }
}

double calculateDistance(double lat1, double lng1, double lat2, double lng2) {
    // Haversine formula for distance calculation
    double dLat = toRadians(lat2 - lat1);
    double dLng = toRadians(lng2 - lng1);
    
    double a = sin(dLat/2) * sin(dLat/2) + 
               cos(toRadians(lat1)) * cos(toRadians(lat2)) * 
               sin(dLng/2) * sin(dLng/2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1-a));
    return c; // Returns distance in radians (multiply by Earth radius for meters)
}

double calculateBearing(double lat1, double lng1, double lat2, double lng2) {
    double dLng = toRadians(lng2 - lng1);
    double lat1Rad = toRadians(lat1);
    double lat2Rad = toRadians(lat2);
    
    double y = sin(dLng) * cos(lat2Rad);
    double x = cos(lat1Rad) * sin(lat2Rad) - sin(lat1Rad) * cos(lat2Rad) * cos(dLng);
    
    double bearing = toDegrees(atan2(y, x));
    return fmod((bearing + 360.0), 360.0); // Normalize to 0-360
}

double toRadians(double deg) {
    return deg * PI / 180.0;
}

double toDegrees(double rad) {
    return rad * 180.0 / PI;
}

void checkWaypointReached() {
    if (currentWaypoint >= NUM_WAYPOINTS) return;
    
    double distance = calculateDistance(
        currentLat, currentLng, 
        WAYPOINTS[currentWaypoint][0], 
        WAYPOINTS[currentWaypoint][1]
    );
    
    if (distance <= WAYPOINT_THRESHOLD) {
        waypointReached[currentWaypoint] = true;
        Serial.print("‚úÖ WAYPOINT ");
        Serial.print(currentWaypoint + 1);
        Serial.println(" ALCAN√áADO!");
        
        // Pequena pausa comemorativa
        stopAllMotors();
        delay(1000);
        
        currentWaypoint++;
        
        if (currentWaypoint >= NUM_WAYPOINTS) {
            Serial.println("üéâ TODOS OS WAYPOINTS ALCAN√áADOS!");
            Serial.println("ü§ñ Navega√ß√£o aut√¥noma conclu√≠da - Modo manual dispon√≠vel");
            stopAllMotors();
            autonomousMode = false; // Finaliza modo aut√¥nomo
            sonda.varrendo = false; // Desativar sonda
            centralizarSonda();
            printMissionSummary();
        } else {
            Serial.print("üéØ Pr√≥ximo waypoint: ");
            Serial.println(currentWaypoint + 1);
        }
    }
}

void printWaypoints() {
    Serial.println("\nüó∫Ô∏è === WAYPOINTS DEFINIDOS ===");
    for (int i = 0; i < NUM_WAYPOINTS; i++) {
        Serial.print("Waypoint ");
        Serial.print(i + 1);
        Serial.print(": ");
        Serial.print(WAYPOINTS[i][0], 8);
        Serial.print(", ");
        Serial.print(WAYPOINTS[i][1], 8);
        Serial.print(" [");
        Serial.print(waypointReached[i] ? "‚úÖ ALCAN√áADO" : "‚è≥ PENDENTE");
        Serial.println("]");
    }
    
    if (gps.location.isValid()) {
        Serial.println("\nüì° Posi√ß√£o atual:");
        Serial.print("LAT: ");
        Serial.print(currentLat, 8);
        Serial.print(" | LNG: ");
        Serial.println(currentLng, 8);
        
        if (autonomousMode && currentWaypoint < NUM_WAYPOINTS) {
            double distance = calculateDistance(
                currentLat, currentLng,
                WAYPOINTS[currentWaypoint][0], 
                WAYPOINTS[currentWaypoint][1]
            );
            Serial.print("üîç Dist√¢ncia para pr√≥ximo waypoint: ");
            Serial.print(distance * 111320, 1);
            Serial.println(" metros");
        }
    } else {
        Serial.println("\n‚úó GPS sem sinal v√°lido");
    }
    Serial.println();
}

void nextWaypoint() {
    if (currentWaypoint < NUM_WAYPOINTS - 1) {
        currentWaypoint++;
        Serial.print("‚≠ê Pulando para waypoint ");
        Serial.println(currentWaypoint + 1);
    } else {
        Serial.println("‚úó J√° no √∫ltimo waypoint!");
    }
}

void clearWaypointProgress() {
    for (int i = 0; i < NUM_WAYPOINTS; i++) {
        waypointReached[i] = false;
    }
    currentWaypoint = 0;
    Serial.println("üîÑ Progresso dos waypoints resetado");
}

void printMissionSummary() {
    Serial.println("\nüèÅ === MISS√ÉO COMPLETA ===");
    Serial.print("‚úÖ Waypoints alcan√ßados: ");
    
    int reached = 0;
    for (int i = 0; i < NUM_WAYPOINTS; i++) {
        if (waypointReached[i]) reached++;
    }
    
    Serial.print(reached);
    Serial.print("/");
    Serial.println(NUM_WAYPOINTS);
    
    if (reached == NUM_WAYPOINTS) {
        Serial.println("üéâ MISS√ÉO 100% CONCLU√çDA!");
    } else {
        Serial.println("‚ö†Ô∏è Miss√£o incompleta");
    }
    
    // Relat√≥rio da sonda
    Serial.println("\nüìä RELAT√ìRIO DA SONDA:");
    Serial.println("√öltima varredura registrada:");
    printVarreduraCompleta();
    
    Serial.println();
}

void updateGPS() {
    while (gpsSerial.available() > 0) {
        if (gps.encode(gpsSerial.read())) {
            if (gps.location.isUpdated() && gps.location.isValid()) {
                currentLat = gps.location.lat();
                currentLng = gps.location.lng();
                
                // Check waypoint proximity
                if (autonomousMode) {
                    checkWaypointReached();
                }
                
                // Print GPS info less frequently
                static uint8_t gpsCounter = 0;
                if (debugMode && (++gpsCounter >= 20)) {
                    Serial.print("üì° GPS: ");
                    Serial.print(currentLat, 8);
                    Serial.print(", ");
                    Serial.print(currentLng, 8);
                    Serial.print(" | Sat: ");
                    Serial.println(gps.satellites.value());
                    gpsCounter = 0;
                }
            }
        }
    }
}
